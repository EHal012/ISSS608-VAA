{
  "hash": "84945d4d882a580c472f50a518773683",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Hands-on Ex06\"\ndescription: \"Hands-on Ex06\" \ndate: \"May 21, 2025\" \ndate-modified: \"May 21, 2025\" \nformat: html\nauthor: \"YUAN Yihao\" \neditor: visual \nexecute: \n  eval: true \n  echo: true \n  warning: false \n  freeze: true \n---\n\n\n\n# Getting Started\n\n## Install the Packages\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(scales, viridis, lubridate, ggthemes,\n               gridExtra, readxl, knitr, data.table,\n               CGPfunctions, ggHoriPlot, tidyverse)\n```\n:::\n\n\n\n# Plotting Calendar\n\n## The data\n\nFor the purpose of this hands-on exercise, eventlog.csv file will be used. This data file consists of 199,999 rows of time-series cyber attack records by country.\n\n## Importing the data\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nattacks <- read_csv(\"Hands-on_Ex06/eventlog.csv\")\n```\n:::\n\n\n\n## Examining the data structure\n\nkable() can be used to review the structure of the imported data frame\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkable(head(attacks))\n```\n\n::: {.cell-output-display}\n\n\n|timestamp           |source_country |tz              |\n|:-------------------|:--------------|:---------------|\n|2015-03-12 15:59:16 |CN             |Asia/Shanghai   |\n|2015-03-12 16:00:48 |FR             |Europe/Paris    |\n|2015-03-12 16:02:26 |CN             |Asia/Shanghai   |\n|2015-03-12 16:02:38 |US             |America/Chicago |\n|2015-03-12 16:03:22 |CN             |Asia/Shanghai   |\n|2015-03-12 16:03:45 |CN             |Asia/Shanghai   |\n\n\n:::\n:::\n\n\n\nThere are three columns, namely timestamp, source_country and tz.\n\ntimestamp field stores date-time values in POSIXct format.\n\nsource_country field stores the source of the attack. It is in ISO 3166-1 alpha-2 country code.\n\ntz field stores time zone of the source IP address.\n\n## Data preparation\n\n### Step 1: Deriving weekday and hour of day fields\n\nBefore we can plot the calender heatmap, two new fields namely wkday and hour need to be derived. In this step, we will write a function to perform the task.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmake_hr_wkday <- function(ts, sc, tz) {\n  real_times <- ymd_hms(ts, \n                        tz = tz[1], \n                        quiet = TRUE)\n  dt <- data.table(source_country = sc,\n                   wkday = weekdays(real_times),\n                   hour = hour(real_times))\n  return(dt)\n  }\n```\n:::\n\n\n\n### Step 2: Deriving the attacks tibble data frame\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSys.setlocale(\"LC_TIME\", \"C\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"C\"\n```\n\n\n:::\n\n```{.r .cell-code}\nwkday_levels <- c('Saturday', 'Friday', \n                  'Thursday', 'Wednesday', \n                  'Tuesday', 'Monday', \n                  'Sunday')\n\nattacks <- attacks %>%\n  group_by(tz) %>%\n  do(make_hr_wkday(.$timestamp, \n                   .$source_country, \n                   .$tz)) %>% \n  ungroup() %>% \n  mutate(wkday = factor(\n    wkday, levels = wkday_levels),\n    hour  = factor(\n      hour, levels = 0:23))\n```\n:::\n\n\n\n\n### Table below shows the tidy tibble table after processing.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkable(head(attacks))\n```\n\n::: {.cell-output-display}\n\n\n|tz           |source_country |wkday    |hour |\n|:------------|:--------------|:--------|:----|\n|Africa/Cairo |BG             |Saturday |20   |\n|Africa/Cairo |TW             |Sunday   |6    |\n|Africa/Cairo |TW             |Sunday   |8    |\n|Africa/Cairo |CN             |Sunday   |11   |\n|Africa/Cairo |US             |Sunday   |15   |\n|Africa/Cairo |CA             |Monday   |11   |\n\n\n:::\n:::\n\n\n\n## Building the Calendar Heatmaps\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrouped <- attacks %>% \n  count(wkday, hour) %>% \n  ungroup() %>%\n  na.omit()\n\nggplot(grouped, \n       aes(hour, \n           wkday, \n           fill = n)) + \ngeom_tile(color = \"white\", \n          size = 0.1) + \ntheme_tufte(base_family = \"Helvetica\") + \ncoord_equal() +\nscale_fill_gradient(name = \"# of attacks\",\n                    low = \"sky blue\", \n                    high = \"dark blue\") +\nlabs(x = NULL, \n     y = NULL, \n     title = \"Attacks by weekday and time of day\") +\ntheme(axis.ticks = element_blank(),\n      plot.title = element_text(hjust = 0.5),\n      legend.title = element_text(size = 8),\n      legend.text = element_text(size = 6) )\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex06_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\n\nThen we can simply group the count by hour and wkday and plot it, since we know that we have values for every combination thereâ€™s no need to further preprocess the data.\n\n## Building Multiple Calendar Heatmaps\n\nChallenge: Building multiple heatmaps for the top four countries with the highest number of attacks.\n\n## Plotting Multiple Calendar Heatmaps\n\n### Step 1: Deriving attack by country object\n\nIn order to identify the top 4 countries with the highest number of attacks, you are required to do the followings:\n\n1.  count the number of attacks by country,\n2.  calculate the percent of attackes by country, and\n3.  save the results in a tibble data frame.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nattacks_by_country <- count(\n  attacks, source_country) %>%\n  mutate(percent = percent(n/sum(n))) %>%\n  arrange(desc(n))\n```\n:::\n\n\n\n### Step 2: Preparing the tidy data frame\n\nIn this step, you are required to extract the attack records of the top 4 countries from attacks data frame and save the data in a new tibble data frame (i.e. top4_attacks).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntop4 <- attacks_by_country$source_country[1:4]\ntop4_attacks <- attacks %>%\n  filter(source_country %in% top4) %>%\n  count(source_country, wkday, hour) %>%\n  ungroup() %>%\n  mutate(source_country = factor(\n    source_country, levels = top4)) %>%\n  na.omit()\n```\n:::\n\n\n\n### Step 3: Plotting the Multiple Calender Heatmap by using ggplot2 package.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(top4_attacks, \n       aes(hour, \n           wkday, \n           fill = n)) + \n  geom_tile(color = \"white\", \n          size = 0.1) + \n  theme_tufte(base_family = \"Helvetica\") + \n  coord_equal() +\n  scale_fill_gradient(name = \"# of attacks\",\n                    low = \"sky blue\", \n                    high = \"dark blue\") +\n  facet_wrap(~source_country, ncol = 2) +\n  labs(x = NULL, y = NULL, \n     title = \"Attacks on top 4 countries by weekday and time of day\") +\n  theme(axis.ticks = element_blank(),\n        axis.text.x = element_text(size = 7),\n        plot.title = element_text(hjust = 0.5),\n        legend.title = element_text(size = 8),\n        legend.text = element_text(size = 6) )\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex06_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\n\n# Plotting Cycle Plot\n\n## Step 1: Data Import For the purpose of this hands-on exercise, arrivals_by_air.xlsx will be used.\n\nThe code chunk below imports arrivals_by_air.xlsx by using read_excel() of readxl package and save it as a tibble data frame called air.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nair <- read_excel(\"Hands-on_Ex06//arrivals_by_air.xlsx\")\n```\n:::\n\n\n\n## Step 2: Deriving month and year fields Next, two new fields called month and year are derived from Month-Year field.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nair$month <- factor(month(air$`Month-Year`), \n                    levels=1:12, \n                    labels=month.abb, \n                    ordered=TRUE) \nair$year <- year(ymd(air$`Month-Year`))\n```\n:::\n\n\n\n## Step 3: Extracting the target country Next, the code chunk below is use to extract data for the target country (i.e. Vietnam)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nVietnam <- air %>% \n  select(`Vietnam`, \n         month, \n         year) %>%\n  filter(year >= 2010)\n```\n:::\n\n\n\n## Step 4: Computing year average arrivals by month The code chunk below uses group_by() and summarise() of dplyr to compute year average arrivals by month.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhline.data <- Vietnam %>% \n  group_by(month) %>%\n  summarise(avgvalue = mean(`Vietnam`))\n```\n:::\n\n\n\n## Step 5: Plotting the cycle plot The code chunk below is used to plot the cycle plot as shown in Slide 12/23.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() + \n  geom_line(data=Vietnam,\n            aes(x=year, \n                y=`Vietnam`, \n                group=month), \n            colour=\"black\") +\n  geom_hline(aes(yintercept=avgvalue), \n             data=hline.data, \n             linetype=6, \n             colour=\"red\", \n             size=0.5) + \n  facet_grid(~month) +\n  labs(axis.text.x = element_blank(),\n       title = \"Visitor arrivals from Vietnam by air, Jan 2010-Dec 2019\") +\n  xlab(\"\") +\n  ylab(\"No. of Visitors\") +\n  theme_tufte(base_family = \"Helvetica\")\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex06_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n\n\n# Plotting Slopegraph\n\n## Step 1: Data Import Import the rice data set into R environment by using the code chunk below.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrice <- read_csv(\"Hands-on_Ex06/rice.csv\")\n```\n:::\n\n\n\n## Step 2: Plotting the slopegraph Next, code chunk below will be used to plot a basic slopegraph as shown below.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrice %>% \n  mutate(Year = factor(Year)) %>%\n  filter(Year %in% c(1961, 1980)) %>%\n  newggslopegraph(Year, Yield, Country,\n                Title = \"Rice Yield of Top 11 Asian Counties\",\n                SubTitle = \"1961-1980\",\n                Caption = \"Prepared by: Dr. Kam Tin Seong\")\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex06_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "Hands-on_Ex06_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}